<?xml version="1.0" encoding="utf-8" standalone="yes"?><search><entry><title>日常杂谈</title><url>/post/mydayone.html</url><categories><category>myday</category></categories><tags><tag>myday</tag></tags><content type="html"> 日常杂谈专区建设成功 只需要在content文件夹下新建myday文件夹，再把archives文件夹下的_index.md文件移动进来即可新建栏目。</content></entry><entry><title>网安学习路径</title><url>/post/wanganstudy.html</url><categories><category>网安学习</category></categories><tags><tag>网安学习</tag></tags><content type="html"> 网络安全学习路线 一、BurpSuite学习 1、使用浏览器给burp代理，进行拦截，获得数据，然后改文件名字或者MIME，达到符合前后端的过滤要求，等文件成功传输到后端，再用菜刀链接。
2、用BurpSuite扫描网站可以知道有哪些漏洞
二、CIFS服务器（类似ftp服务器） 打开cmd，输入\，打开CIFS，输入ip即可
三、 DHCP部署和安全 DHCP作用（自动分配IP地址） 地址池/作用域：（IP，子网掩码，网关，DNS，租期）， DHCP优点：减少工作量，避免IP冲突，提高地址利用率
DHCP 协议端口是:UDP 67,68 DHCP原理（DHCP租约过程） 分为4个步骤：
1）发送DHCP Discovery 广播包 客户机广播请求IP地址（包含客户机的MAC地址）
2）响应DHCP Offer广播包 服务器响应提供的IP地址（但无子网掩码、网关等参数）
3）发送DHCP Request广播包 客户机选择IP（也可认为确认使用哪个IP）
4）服务器发送DHCP ACK 广播包 服务器确定了租约，并提供网卡详细参数IP、掩码，网关、DNS、租期等
DHCP续约 50%时间过后，客户机会再次发送DHCP Request包，进行续约，如果服务器无响应，则继续使用并在87.5%，再次发送DCHP Request包，进行续约，如X任然无响应，并释放IP地址，及重新发送DHCP Discovery 广播包来获取IP地址，当无任何服务器响应是，自动给自己分配一个169.254.x.x/16，全球统一无效地址，用于临时内网通信！
部署DHCP服务器 客户机验证：
ipconfig /release 释放IP（取消租约，或者改为手动配置IP,也可以释放租约） ipconfig /renew 重新获取IP（有IP时，发送Request续约，无IP时，发送Discovery重新获取） 地址保留 对指定的MAC地址，固定动态分配IP地址
DHCP 攻击与防御 1）攻击DHCP服务器： 频繁的发送伪装DHCP请求，直到将DHCP地址池资源耗尽
防御：在交换机（管理型）端口上做动态MAC地址绑定
2）伪装DHCP 服务器攻击： hack通过将自己部署的DHCP服务器，为客户及提供非法IP
防御：在交换机上（管理型），除合法的DHCP服务器所在的接口外，全部设置为禁止发送DHCP …</content></entry><entry><title>域外高人世界</title><url>/post/000.html</url><categories><category>前辈</category></categories><tags/><content type="html"> 随机世界博客 CS自学指南 学习c语言快速入门 学习网络攻防原理 计算机基础 这里是计算机基础知识的总结 算法刷题 总结网站 # 前端面试指南 面试总结 前端进阶 被删的前端游乐场 互联网大厂面试每日一题 # JavaScript 后盾人 学习路线 JavaScript专题系列20篇正式完结！ (建议收藏)原生JS灵魂之问, 请问你能接得住几个？(上) 神三元 LinDaiDai_霖呆呆 冴羽 Sunshine_Lin # 执行上下文/作用域/闭包/this 【译】理解 Javascript 执行上下文和执行栈 我从来不理解JavaScript闭包，直到有人这样向我解释它&amp;hellip; 【建议👍】再来40道this面试题酸爽继续(1.2w字用手整理) JavaScript进阶-执行上下文栈和变量对象(一周一更) # 对象/原型链/继承 详解JS原型链与继承 最详尽的 JS 原型与原型链终极详解，没有「可能是」。 💦【何不三连】做完这48道题彻底弄懂JS继承(1.7w字含辛整理-返璞归真) 读书笔记之创建对象 JavaScript常用八种继承方案 # event loop 深入理解 JavaScript Event Loop 一次弄懂Event Loop（彻底解决此类面试问题） 浏览器与Node的事件循环(Event Loop)有何区别? # js其他知识点 你真的理解事件冒泡和事件捕获吗？ # ES6 阮一峰大佬的博客 ES6、ES7、ES8特性一锅炖(ES6、ES7、ES8学习指南) 近一万字的ES6语法知识点补充 1.5万字概括ES6全部特性(已更新ES2020) 🎉喜大普奔，ES2019登场 ES6 完全使用手册 ES9已经来了 Are you ready? # 浏览器原理 渲染机制 (1.6w字)浏览器灵魂之问，请问你能接得住几个？ 前端开发的你应该知道的浏览器知识 傻傻分不清之 Cookie、Session、Token、JWT 从浏览器多进程到JS单线程，JS运行机制最全面的一次梳理 # 面试算法刷题 codeTop</content></entry><entry><title>记微信助手死去的一天</title><url>/post/takeoutmywechat.html</url><categories><category>myday</category></categories><tags><tag>myday</tag></tags><content type="html"> 后悔了，把微信从3.6更新到4.0版本，虽然界面看着好看但已经我的微信工具全都死了，仅以此文悼念我的微信小工具，以下是小工具们的名单，也给各位没有更新微信的佬指路。
chatlog微信解密提供http服务器 wechatDataBackup 留痕微信记录工具，这个好像是作者删掉的，但我还有2-0-10和-16，不知道行不行
wechat-dump-rs 这个作者更新了，写着支持4.0版本，但我还没用
微信朋友圈导出工具 ，这个我第一次用可以，但后面都不行了，本来是想保存大学crash的朋友圈来着，后面打开就不行了</content></entry><entry><title>使用hugo框架+github action创建个人博客</title><url>/post/hugo+githubactionstudy.html</url><categories><category>个人博客</category><category>hugo</category></categories><tags><tag>个人博客</tag><tag>hugo</tag></tags><content type="html"> 使用hugo框架+github action创建个人博客 本操作是使用静态页面后的进阶操作，主要是为了省去在本地进行hugo编译的步骤。理想的状态是，我只负责写文，和将好的md提交到git备份，然后就可以坐等网站内容更新了，官方提供的GitHub Action正可以满足这个需求。
需要管理两个仓库，一个是原先的静态仓库，一个是整个hugo仓库
Github Action需要做两件事：
编译，生成静态文件 部署，把静态文件移动到合适的位置 主要流程 配置私有hugo库的Github Action 配置合适的token 在hugo博客根目录下，创建放置Github Action 配置文件 的目录 .github/workflows；在 .github/workflows目录下，创建一个 yml文件 ，这就是Github Action需要的一个工作流的配置，如果需要多个工作流可以创建多个yml文件
博主.yml文件示例
name: deploy # 代码提交到main分支时触发github action on: push: branches: - main jobs: deploy: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v4 with: fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v3 with: hugo-version: &amp;amp;#34;0.116.0&amp;amp;#34; # 可以修改为你使用的 Hugo 版本 extended: true - name: Build Web run: hugo -D - name: Deploy Web uses: peaceiris/actions-gh-pages@v4 with: PERSONAL_TOKEN: ${{ secrets.PERSONAL_TOKEN }}#对应静态页面库的密钥 EXTERNAL_REPOSITORY: 0linkun/0linkun.github.io# 修改为你的 GitHub Pages 仓库 PUBLISH_BRANCH: main PUBLISH_DIR: ./public#把本地生成的public文件夹下的文件部署到静 …</content></entry><entry><title>基于P2P+组播的文件传输工具</title><url>/post/P2PFile.html</url><categories><category>app</category></categories><tags><tag>P2P</tag><tag>组播</tag></tags><content type="html"> 基于P2P+组播的文件传输工具 项目概述 本项目是一个基于局域网（或本地测试环境）的简易P2P文件传输程序，目前处于基本完成状态。环境java16
任意客户端可以进行局域网通信，聊天，传输文件到服务器
通过组播组对组播内其他客户端发送文件
任意端通过浏览器访问web页面下载、上传文件
获得在线用户列表
一键与其他客户端文件同步
数据加密
组播发送进度条
实现轮询节点下载文件分块
基于P2P的文件传输工具</content></entry><entry><title>行测词语成语积累</title><url>/post/%E8%A1%8C%E6%B5%8B%E8%AF%8D%E8%AF%AD%E6%88%90%E8%AF%AD%E7%A7%AF%E7%B4%AF.html</url><categories><category>gwy</category></categories><tags><tag>gwy</tag></tags><content type="html"> 在备考中，我发现有相当多的高频成语出现在全国各地的行测真题中。相比于常识，成语的范围其实相当有限，常用的成语不过成百上千个，因此在平时可以用记忆的方式进行备考。江苏省考中，直接涉及成语的题目是言语理解与表达中的选词填空、判断推理中的类比推理，所占分值高达6、7分。同时，成语的使用对申论大作文写作也有一定的帮助，可以让遣词造句更加简练、文雅。 我将收集到的成语（包含少量词语）进行适当分组，便于平日里的背诵记忆。 组一 词语/成语 释义 鸱目虎吻 人相貌阴险凶恶 车载斗量 数量很多、不足为奇 明眸皓齿 面容美丽 衣冠枭獍 行为恶劣、如同禽兽的人 穰穰满家 获得丰收，粮食满仓 勃然而兴 兴起或旺盛的样子 泥古不化 拘守古代的成规或古人的说法而不知变通 坐而论道 坐在那里高谈阔论空洞的道理 如芒在背 极度不安 曲突徙薪 事先采取措施，才能防止灾祸 闭门造车 自作主张、不合实际 剑走偏锋 不走常规，找一些新的、不同以往的办法来解决问题，以求出奇制胜 李代桃僵 以此代彼或代人受过 鞭打快牛 冲在最前面的也是最容易受伤的 狼多肉少 供不应求 根深叶茂 基础牢固，就会兴旺发展 盘根错节 事物的关系错综复杂，很难处理 珠辉玉丽 佳丽的肌肤之美，用于女性 明灭可见 忽明忽暗 如日中天 事物正发展到十分兴盛的阶段 巡游 外出游玩、游逛 洄游 鱼类因产卵、觅食或受季节变化影响，沿着一定路线有规律地往返迁移 巡回 按一定的路线或范围到处活动 逡巡 有所顾虑而徘徊或不敢前进 遽然、蓦然 突然、猛然 组二 词语/成语 释义 垂爱 上对下或别人对自己赏识爱护 疏放 任性而为、不检点；文章不受常格拘束 风流云散 向四处分散消失 风雨同舟 共同度过困难 通同一气 互相串通勾结在一起 鸠占鹊巢 强占别人的位置、居所或产业 更弦易辙 改变方法或态度 蔚然成风 一种事物逐渐发展、盛行，形成（好的）风气 一马当先 领先、带头 立竿见影 收效非常迅速 言不及义 说话不涉及正经道理 夜郎自大 妄自尊大，骄傲无知，肤浅自负 坐井观天 眼界狭小，所见有限 抱残守缺 思想保守，不肯接受新事物 因循守旧 照老样子不改，不求革新 言简意赅 说话或写文章言语简明而意思完备 拈轻怕重 工作上怕挑重担子 惺惺相惜 聪明才智相当的人彼此同情、怜惜 作壁上观 坐观成败，不给予帮助 刻舟求剑 办事刻板拘泥，不知根据实际情况处理问题 …</content></entry><entry><title>查看开放端口</title><url>/post/%E6%9F%A5%E7%9C%8B%E5%BC%80%E6%94%BE%E7%AB%AF%E5%8F%A3.html</url><categories><category>linux</category><category>window</category></categories><tags><tag>linux</tag><tag>window</tag></tags><content type="html"><![CDATA[  linux netstat命令：　查询显示网络连接、路由表和网络接口等信息。使用以下命令可以查看当前开启的端口
命令参数：
-a或–all 显示所有连线中的Socket。 -A&amp;lt;网络类型&amp;gt;或–&amp;lt;网络类型&amp;gt; 列出该网络类型连线中的相关地址。 -c或–continuous 持续列出网络状态。 -C或–cache 显示路由器配置的快取信息。 -e或–extend 显示网络其他相关信息。 -F或–fib 显示FIB。 -g或–groups 显示多重广播功能群组组员名单。 -h或–help 在线帮助。 -i或–interfaces 显示网络界面信息表单。 -l或–listening 显示监控中的服务器的Socket。 -M或–masquerade 显示伪装的网络连线。 -n或–numeric 直接使用IP地址，而不通过域名服务器。 -N或–netlink或–symbolic 显示网络硬件外围设备的符号连接名称。 -o或–timers 显示计时器。 -p或–programs 显示正在使用Socket的程序识别码和程序名称。 -r或–route 显示Routing Table。 -s或–statistice 显示网络工作信息统计表。 -t或–tcp 显示TCP传输协议的连线状况。 -u或–udp 显示UDP传输协议的连线状况。 -v或–verbose 显示指令执行过程。 -V或–version 显示版本信息。 -w或–raw 显示RAW传输协议的连线状况。 -x或–unix 此参数的效果和指定”-A unix”参数相同。 –ip或–inet 此参数的效果和指定”-A inet”参数相同。 例子： netstat -tuln netstat -ano 该命令会列出所有TCP和UDP协议的监听端口。其中，-t参数表示显示TCP协议，-u表示显示UDP协议，-l表示只显示监听状态的端口，-n表示以数字形式显示端口号。
ss命令：　比 netstat 好用的socket统计信息，iproute2 包附带的另一个工具，允许你查询 socket 的有关统计信息　-h, --help 帮助信息 -V, --version 程序版本信息 -n, --numeric 不解析服务名称 -r, --resolve 解析主机名 -a, --all 显示所有套接字（sockets） …  ]]></content></entry><entry><title>菜刀、蚁剑、冰蝎流量特征</title><url>/post/webshell.html</url><categories><category>webshell</category></categories><tags><tag>webshell</tag></tags><content type="html"><![CDATA[  菜刀 使用了base64的方式加密了发送给“菜刀马”的指令，其中的两个关键payload z1和z2，这个名字是可变的
蚁剑 默认的USER-agent请求头 是 antsword xxx，但是 可以通过修改：/modules/request.js 文件中 请求UA绕过，现在版本已经自己修改const USER_AGENT = require(&amp;lsquo;random-fake-useragent&amp;rsquo;);也可以看随机useragent访问同一个文件的频率
其中流量最中明显的特征为@ini_set(&amp;ldquo;display_errors&amp;rdquo;,&amp;ldquo;0&amp;rdquo;);这段代码基本是所有WebShell客户端链接PHP类WebShell都有的一种代码。一些敏感函数比如@str_rot13 chr(105) @ini_set 这种类型的。常规waf 可以拦截的很死
蚁剑混淆加密后还有一个比较明显的特征,即为参数名大多以“_0x&amp;hellip;&amp;hellip;=”这种形式（下划线可替换），所以以_0x开头的参数名也很可能就是恶意流量
冰蝎 看包没有发现什么特征，但是可以发现它是POST请求的
1、Accept头有application/xhtml+xmlapplication/xmlapplication/signed-exchange属于弱特征（UA头的浏览器版本很老）
2、特征分析Content-Type: application/octet-stream 这是一个强特征查阅资料可知octet-stream的意思是，只能提交二进制，而且只能提交一个二进制，如果提交文件的话，只能提交一个文件,后台接收参数只能有一个，而且只能是流（或者字节数组）；很少使用
#冰蝎2特征：
默认Accept字段的值很特殊,而且每个阶段都一样冰蝎内置了十余种UserAgent ，每次连接 shell 会随机选择一个进行使用。但都是比较老的，r容易被检测到，但是可以在burp中修改ua头。
Content-Length: 16, 16就是冰蝎2连接的特征
#冰蝎3特征：
冰蝎3取消动态密钥获取，目前很多waf等设备都做了冰蝎2的流量特征分析，所以3取消了动态密 钥获取；php抓包看包没有发现什么特征，但是可以发现它是POST请求的
1）Accept …  ]]></content></entry><entry><title>Django项目学习(一)</title><url>/post/DjangoOne.html</url><categories><category>Django</category></categories><tags><tag>Django</tag><tag>Python</tag></tags><content type="html"><![CDATA[  manage.py: 一个实用的命令行工具，可让你以各种方式与该 Django 项目进行交互。
默认目录 Sec_Tools/init.py一个空文件，告诉 Python 该目录是一个 Python 包。
项目目录设置Sec_Tools/urls.py 该 Django 项目的 URL 声明; 一份由 Django 驱动的网站&amp;quot;目录&amp;quot;。
urlpatterns = [ path(&amp;#39;admin/&amp;#39;, admin.site.urls), path(&amp;#39;&amp;#39;, include(&amp;#39;webscan.urls&amp;#39;)), # 信息收集，前端页面 path(&amp;#39;&amp;#39;, include(&amp;#39;login.urls&amp;#39;)), # 登录注册 path(&amp;#39;&amp;#39;, include(&amp;#39;dirscan.urls&amp;#39;)), # 目录识别 path(&amp;#39;&amp;#39;, include(&amp;#39;vulnscan.urls&amp;#39;)), # 漏洞检测 path(&amp;#39;webscan_backend/&amp;#39;, include(&amp;#39;webscan_backend.urls&amp;#39;)), # 后端接口 re_path(r&amp;#39;media/(?P&amp;lt;path&amp;gt;.*)$&amp;#39;, serve, {&amp;#39;document_root&amp;#39;:settings.MEDIA_ROOT}), ] 项目入口Sec_Tools/wsgi.py 一个 WSGI 兼容的 Web 服务器的入口，以便运行你的项目。
项目入口Sec_Tools/asgi.py 一个 ASGI 兼容的 Web 服务器的入口，以便运行你的项目
ASGI（Asynchronous Server Gateway Interface）和WSGI（Web Server Gateway Interface）都是Python的服务器网关接口，用于定义Web服务器和Web应用程序或框架之间的通信标准。ASGI相对于WSGI具有更高的性能和更多的功能，尤其是在处理现代Web应用中的并发请求和实时通信方面。然而，这也意味着开发者需要了解并处理异步编程的复杂性
项目设置Sec_Tools/settings.py …  ]]></content></entry><entry><title>tostring和getbytes不能一起使用</title><url>/post/tostring%E5%92%8Cgetbytes%E4%B8%8D%E8%83%BD%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8.html</url><categories><category>java</category><category>tostring</category></categories><tags><tag>java</tag><tag>tostring</tag></tags><content type="html"> 问题 a.equals(a.getBytes().toString()为什么是false
解答 a.equals(a.getBytes().toString()) 这一表达式返回 false 的原因是 equals() 方法在比较字符串时，不仅比较字符本身，还会比较两个字符串的内部表示，包括它们在内存中的地址和字节编码。
a.getBytes()：这一部分将字符串 a 转换为一个字节数组。默认情况下，它会使用系统的默认字符集（例如 UTF-8）来转换字符串。 .toString()：这一部分将字节数组转换为一个字符串。在 Java 中，字节数组默认使用 [B 格式化为字符串。 a.equals(...)：这一部分使用 equals() 方法比较两个字符串。在比较时，它不仅会比较字符串的字符内容，还会比较它们的内部表示，包括它们在内存中的地址和字节编码。 由于 a.getBytes() 和 a.toString() 的行为是不同的，所以它们产生的结果也是不同的。具体来说，a.getBytes() 返回的是根据默认字符集编码的字节数组，而 a.toString() 返回的是字节数组的默认表示（即 [B）。因此，即使这两个操作的结果在视觉上看起来相同，它们实际上并不相等。
要使表达式 a.equals(a.getBytes().toString()) 返回 true，你需要使用与 getBytes() 相同的方式来转换字符串：
String b = new String(a.getBytes()); boolean result = a.equals(b); 这样，b 就会使用与 a.getBytes() 相同的字符集来从字节数组转换回字符串，从而使得 a.equals(b) 返回 true。</content></entry><entry><title>当前的我究竟为什么而活</title><url>/post/TheSecretLifeofWalterMitty.html</url><categories><category>电影感悟</category></categories><tags><tag>电影感悟</tag></tags><content type="html"> 观影背景 1、在回来的高铁上为了不浪费时间，又因为没有网，所以提前下载了一部电影——白日梦想家。
2、之前经常听说过这部电影，但有时候静不下心来看它，觉得只是一个普通的电影。
电影大致内容 ​ 影片讲述了本·斯蒂勒所饰演的男主角穿行在现实和自己的白日梦里，最终踏上一场真正的人生大冒险, 并与女主角克里斯汀·韦格展开一场绝妙的浪漫奇缘。
​ 按部就班，生活单调，害怕尝试，幻想勇敢，这是米蒂 ，也是无数个藏在人群中的曾经或者现在的我们。主人公米蒂其实很容易让生活中正处于青春期的男生或者一事无成的大人代入其中，就好像我一样，平时经常做着白日梦，有时候幻想英雄救美、有时候幻想上天入地，电影的前面无疑是把一个正常的现象展现给我们看，一个人边上班做着打工仔，边看着隔壁部门的美女发呆，幻想着自己和美女的邂逅。这个时候噩梦也到了——公司打算缩减裁员，而米蒂所在的底片资产部在考核中，决定米蒂去留的一个照片不见了。它是最厉害的冒险摄影师尚·恩康诺给米蒂最后的礼物，也是摄影师认为的最好的照片。如果没有这个照片，米蒂就会失去工作。没有办法，他只能是为了工作去寻找摄影师。
触动 ​ 一个普普通通的上班族，为了自己的工作踏上了冒险摄影师的足迹。在这一次旅途中，他不断做着白日梦，他幻想自己变成超人、变成勇士去反驳上司，却因为终日的放空幻想而被同事上司嘲笑，胆怯内向的性格使他甚至连和暗恋对象说话的勇气都没有。在他的幻想里他是独一无二的的英雄，而在他的生活里却是发呆不止的大叔。
​ 一个不翼而飞的底片，没有人知道真相是什么，从格陵兰岛到冰岛，从火山到雪山，上到乘坐醉酒机长的直升机，下到跳入海中与鲨鱼搏斗…… 再到最后兜兜转了一圈，发现真相就在自己手中，而照片上的人，正是他自己。他是摄影师眼里对工作最认真的侠客。
​ 当我看到杂志的名字是LIFE——生活时，确实有所触动，当我们寻寻觅觅去找到生活中最有意义的底片时，我们以为这个底片它是雪峰上的雪豹、大海里的风暴，但冒险摄影师告诉我们，它是你手中的认真、执着。每个人都有每个人不同的答案，我们在追求着不同的生活方式，但最终，我们都在寻找同一样东西：生活的意义。生活，这个看似简单却充满无限可能的词语，是每一个人的起点和终点。我们都从生活中汲取养分，感受喜怒哀乐，体验生老病死。每个人都是自己生活的导演，我们用各自的方式演绎着各自的人生。 ​ 有人追求物质的富 …</content></entry><entry><title>GO笔记（一）</title><url>/post/GoOne.html</url><categories><category>GO</category></categories><tags><tag>GO</tag></tags><content type="html"><![CDATA[  一、helloworld package main import &amp;#34;fmt&amp;#34; func main() { fmt.Println(&amp;#34;Hello World&amp;#34;) } 二、变量声明 和C的完全相反，变量类型在后面，在变量名前面的是var
var area int var age int = 29 // 声明变量并初始化 var width, height int var width, height int = 100, 50 // 声明多个 var ( name = &amp;#34;naveen&amp;#34; age = 29 height int ) name, age := &amp;#34;naveen&amp;#34;, 29 // 简短声明 name, age := &amp;#34;naveen&amp;#34; //error 简短声明的语法要求 := 操作符的左边至少有一个变量是尚未声明的
a, b := 20, 30 // 声明变量a和b b, c := 40, 50 // b已经声明，但c尚未声明 b, c = 80, 90 // 给已经声明的变量b和c赋新值 a, b := 20, 30 // 声明a和b a, b := 40, 50 // 错误，没有尚未声明的变量 上面运行后会抛出 no new variables on left side of := 的错误，因为 a 和 b 的变量已经声明过了，:= 的左边并没有尚未声明的变量
age := 29 // age是int类型 age = &amp;#34;naveen&amp;#34; // 错误，尝试赋值一个字符串给int类型变量 Go 是强类型（Strongly Typed）语言，因此不允许某一类型的变量赋值为其他类型的值。下面的程序会抛出错误 cannot use &amp;quot;naveen&amp;quot; (type string) as type int in assignment，这是因为 age 本来声明为 int 类型，而我们却尝试给它赋字符串类型的值。
三、变量类型 下面是 Go 支持的基本类型：
bool 数字类型 int8, int16, int32, int64, int uint8, uint16, uint32, uint64, uint float32, float64 complex64, …  ]]></content></entry><entry><title>中国蚁剑-AntSword</title><url>/post/AntSwordstudy.html</url><categories><category>AntSword</category></categories><tags><tag>AntSword</tag></tags><content type="html"> 中国蚁剑是一种跨平台操作工具，它主要提供给用户用于有效的网络渗透测试以及进行正常运行的网站。 否则任何人不得将网站用于其无效用途以及可能的等目的。自己承担并追究其相关责任！
原文链接： 中国蚁剑 - AntSword 1.入门学习 入门学习可以参考https://www.yuque.com/antswordproject/antsword/lmwppk，这是AntSword的Github提供的语雀文档。
1.下载蚁剑加载器
从 v2.0.0-beta 版本开始，我们引入了加载器这一概念。用户/开发者只需要下载对应平台的加载器，无需安装额外的环境，即可对源代码进行编辑/执行/调试等操作。可直接运行当前最新的开发版和发行版源代码。
加载器与核心不同，在GitHub的https://github.com/AntSwordProject/antSword中，存放的是核心。下载过后，放置在一个目录中。
antSword是核心，AntSword-Loader是加载器。
README.me中有详细的介绍。
注意：官方加载器仅在 https://github.com/AntSwordProject/AntSword-Loader 发布，不会在网盘等其它网站发布，下载后请第一时间校验 md5 值
下载蚁剑源代码并加载 首次打开加载器时，界面如下图所示：
点击「初始化」按钮，选择一个空目录作为蚁剑的工作目录，加载器会自动下载源代码。待提示初始化完毕时，重新打开蚁剑加载器，即可看到蚁剑的主界面。
当然了，如果你之前已经有了蚁剑源代码，你可以在这一步选择工作目录的时候，直接选择该目录作为工作目录。接着你需要手动打开蚁剑主程序
国内用户建议自己下载，蚁剑自身下载过程不会很快，因为是从GitHub上下载。 你是否还沉浸在愉悦的安装过程中？很遗憾，一切皆已完成。：）
可能遇到的问题
Q: 下载或者解压出错
A: 遇到这种问题，按照下面步骤手动进行：
手动 clone antsword 源代码, 或者直接点 这里下载源代码 并解压 $ git clone https://github.com/AntSwordProject/AntSword.git 打开加载器，选择源代码所在目录(简单理解为 app.js 所在目录)。 例如app.js路径为：D:\\test\antsword\app.js，那么 …</content></entry><entry><title>nc学习使用</title><url>/post/ncstudy.html</url><categories><category>nc</category></categories><tags><tag>网安学习</tag><tag>nc</tag></tags><content type="html"> nc (ncat) Ncat is a feature-packed networking utility which reads and writes data across networks from the command line；
nc(ncat)：Ncat是一个功能丰富的网络实用工具；支持端口监听、远程通信、文件传输、端口扫描、反向Shell、端口转发功能；
格式：ncat [OPTIONS&amp;amp;hellip;] [hostname] [port]
常用参数：
OPTIONS 意义 -l 使用监听模式，意味着nc被当作server，侦听并接受连接，而非向其它地址发起连接 -p 设置本地主机使用的通信端口 -s 设置本地主机送出数据包的IP地址 -u 使用UDP传输协议 -v 显示指令执行过程 -w 设置等待连线的时间 -z 使用0输入/输出模式，只在扫描通信端口时使用 -c 针对命令的传送，在后面能看到例子 -e 和-c一样的 -b 允许广播 -g 设置路由器通信网关数量，最多设置八个 -G 设置来源路由指向器，其数值为4的倍数。 -h 帮助信息 -i 延迟几秒，通常用户发送以及扫描端口 -k 设置keepalive选项 -n 直接使用ip而不是使用域名 -0 指定文件名称，把往来传输的数据以16进制字码倾倒成该文件保存。 -r 乱数指定本地与远端主机的通信端口 -q 传输结束后几秒断开 -T 设置服务类型 -t 回应telnet协商 -C 结束 nc、netcat、ncat区别：
nc与netcat是一个组件，ncat是nmap分支下的一个命令； nc / ncat 在CentOS 上是同一个命令工具，是一个功能丰富的网络实用程序，可通过命令行在网络上读写数据； 使用 ncat 时，尽量不要使用 nc，避免与 netcat 冲突； 若安装了ncat时，nc、netcat都成了ncat的alias，命令行里输入这三者都是一样的； netcat和ncat的-z参数是不相等的； 可通过rpm -qa|grep nc命令，查看nc是指netcat还是ncat； Ncat是在原始Netcat之上新增功能二次开发的另一款强大工具，也就是说Netcat有的功能Ncat都具备，并且Ncat还有更多强大的功能。 参考案例：
扫描80端口 # nc可用ncat代替 $ nc …</content></entry><entry><title>各个语言做服务器</title><url>/post/%E7%AE%80%E6%98%93%E6%9C%8D%E5%8A%A1%E5%99%A8.html</url><categories><category>python</category><category>java</category></categories><tags><tag>计算机网络</tag></tags><content type="html"> Python python -m SimpleHTTPServer
默认的端口号是8000， 服务器根目录就是运行python命令的工作目录
如果是python3版本：
则试一下命令：
python -m http.server
用http://127.0.0.1:8000即可访问目录下内容
服务器关闭： 1） dos 在运行界面中输入 &amp;ldquo;ctrl + C&amp;rdquo; 停止 2）python脚本 需停止端口监听及相关python进程
def stop_server(server) server.sorket.close() ========================
用于搭建http server的模块有如下三种： 1）BaseHTTPServer：提供基本的Web服务和处理器类，分别是HTTPServer及BaseHTTPRequestHandler； 2）SimpleHTTPServer：包含执行GET和HEAD请求的SimpleHTTPRequestHandler类； 3）CGIHTTPServer：包含处理POST请求和执行的CGIHTTPRequestHandler类。
Java Java实现一个简单的http服务器_java写一个http服务-CSDN博客</content></entry><entry><title>当你上网的那瞬间发生了什么？</title><url>/post/startWeb.html</url><categories><category>计算机网络</category><category>计算机硬件</category></categories><tags><tag>计算机网络</tag><tag>计算机硬件</tag></tags><content type="html"><![CDATA[  这个仓库试图回答一个古老的面试问题：当你在浏览器中输入 google.com 并且按下回车之后发生了什么？
不过我们不再局限于平常的回答，而是想办法回答地尽可能具体，不遗漏任何细节。
按下&amp;quot;g&amp;quot;键 接下来的内容介绍了物理键盘和系统中断的工作原理，但是有一部分内容却没有涉及。当你按下&amp;quot;g&amp;quot;键，浏览器接收到这个消息之后，会触发自动完成机制。浏览器根据自己的算法，以及你是否处于隐私浏览模式，会在浏览器的地址框下方给出输入建议。大部分算法会优先考虑根据你的搜索历史和书签等内容给出建议。你打算输入 &amp;quot;google.com&amp;quot;，因此给出的建议并不匹配。但是输入过程中仍然有大量的代码在后台运行，你的每一次按键都会使得给出的建议更加准确。甚至有可能在你输入之前，浏览器就将 &amp;quot;google.com&amp;quot; 建议给你。
回车键按下 为了从零开始，我们选择键盘上的回车键被按到最低处作为起点。在这个时刻，一个专用于回车键的电流回路被直接地或者通过电容器间接地闭合了，使得少量的电流进入了键盘的逻辑电路系统。这个系统会扫描每个键的状态，对于按键开关的电位弹跳变化进行噪音消除(debounce)，并将其转化为键盘码值。在这里，回车的码值是13。键盘控制器在得到码值之后，将其编码，用于之后的传输。现在这个传输过程几乎都是通过通用串行总线(USB)或者蓝牙(Bluetooth)来进行的，以前是通过PS/2或者ADB连接进行。
USB键盘：
键盘的USB元件通过计算机上的USB接口与USB控制器相连接，USB接口中的第一号针为它提供了5V的电压 键码值存储在键盘内部电路一个叫做&amp;quot;endpoint&amp;quot;的寄存器内 USB控制器大概每隔10ms便查询一次&amp;quot;endpoint&amp;quot;以得到存储的键码值数据，这个最短时间间隔由键盘提供 键值码值通过USB串行接口引擎被转换成一个或者多个遵循低层USB协议的USB数据包 这些数据包通过D+针或者D-针(中间的两个针)，以最高1.5Mb/s的速度从键盘传输至计算机。速度限制是因为人机交互设备总是被声明成&amp;quot;低速设备&amp;quot;（USB 2.0 compliance） 这个串行信号在计算机的USB控制器处被解码，然后被人机交互设备通用键盘驱动进行进一步解释。之 …  ]]></content></entry><entry><title>OPTION为跨域请求准备</title><url>/post/OPTIONstudy.html</url><categories><category>OPTION</category><category>跨域请求</category></categories><tags><tag>OPTION</tag><tag>跨域请求</tag></tags><content type="html"><![CDATA[  OPTION为跨域请求准备 先学习一下同源策略和跨域资源共享
同源策略 如果两个URL协议(protocol)、端口（port）、主机（host）,都相同，则称这个URL为同源。CORS它是W3C万维网联盟的标准，它定义了在跨域访问资源时浏览器和服务器之间如何通信。它是为突破同源策略的限制而出现的一种官方标准的跨域解决方案。在实战场景中，跨域场景太为常见了（特别是当下前后端分离的开发模式），因此深入理解CORS变得就异常的重要了（反倒前端工程师不用太了解）。
以http://music.javaswing.cn/home/index.html
URL 结果 原因 http://music.javaswing.cn/static/other.html 同源 http://music.javaswng.cn/inner/start.html 同源 http://music.javaswing.cn:8000/other.html 不同源 端口不同 https://music.javaswing.cn/inner/start.html 不同源 协议不同 http://api.javaswing.cn/start.html 不同源 主机不同 作用：同源策略的存在，主要是为用于限制文档与它加载的脚本如何能与另一个资源进行交互，为重要的安全策略。
比如：你本地http://localhost:3000的项目访问http://localhost:8000的项目，就会出现：has been blocked by CORS policy
Access to XMLHttpRequest at &amp;lsquo;http://localhost:3000/&amp;rsquo; from origin &amp;lsquo;http://localhost:8080&amp;rsquo; has been blocked by CORS policy: Response to preflight request doesn&amp;rsquo;t pass access control check: No &amp;lsquo;Access-Control-Allow-Origin&amp;rsquo; header is present on the requested resource.
CORS 跨域资源共享(CORS) 是一种机 …  ]]></content></entry><entry><title>谷歌搜索语法</title><url>/post/google%E6%90%9C%E7%B4%A2%E8%AF%AD%E6%B3%95.html</url><categories><category>谷歌搜索</category></categories><tags><tag>谷歌搜索</tag></tags><content type="html"> 语法 注释 inurl://admin/login.php 查找管理员登陆页面 inurl:phpmyadmin/index.php 查找后台数据库管理页面 inurl:Login admin 返回url中含有Login和admin的网页 site:baidu.com inurl:Login 只在baidu.com中查找url中含有Login的网页 site:baidu.com filetype:pdf 只返回baidu.com站点上文件类型为pdf的网页 link:www.baidu.com 返回所有包含指向 www.baidu.com 的网页 related:www.llhc.edu.cn 返回与 www.llhc.edu.cn 网页布局相似的页面 info:www.baidu.com 返回百度的一些信息 define:Hacker 返回关于Hacker的定义 site:xx.com intext:管理 site:xx.com inurl:login site:xx.com intitle:后台 查找网站后台 site:xx.com filetype:php 查看服务器使用的程序 site:xx.com inurl:file site:xx.com inurl:load 查看上传漏洞 大致命令： intext：寻找正文中含有关键字的网页 intitle：寻找标题中含有关键字的网页 allintitle：用法和intitle类似，只不过可以指定多个词 inurl：将返回url中含有关键词的网页 allinurl：用法和inurl类似，只不过可以指定多个词 site：指定访问的站点 filetype：指定访问的文件类型 link：指定链接的网页 related：相似类型的网页 info：返回站点的指定信息 define：返回某个词语的定义 上面这些命令中用的最多的就是 inurl: 了，利用这个命令，可以查到很多意想不到的东西
inurl inurl:admin filetype:txt inurl:admin filetype:db inurl:admin filetype:cfg inurl:mysql filetype:cfg inurl:passwd filetype:txt inurl:”wwwroot/*.” inurl:adpassword.txt …</content></entry><entry><title>快捷键汇总</title><url>/post/fastkeyboard.html</url><categories><category>软件</category></categories><tags><tag>notepad</tag></tags><content type="html"> notepad&amp;ndash; 选择指定行 鼠标光标停留在一行的某处，按 Home 键光标会跳到行首，按End键光标会跳到行尾。
鼠标光标停留在行尾，按 Shift + Home 选中一行。
鼠标光标停留在行首，按 Shift + End 选中一行。
鼠标光标停留在类中某处，按 Shift + PageUp 选中类的光标前面所有内容。
鼠标光标停留在类中某处，按 Shift + PageDown 选中类的光标后面所有内容。
选中所有内容，Ctrl + A 。
要选中一行可以先按Home键，然后再按Shift + End 选中一行。
逐个选择 ctrl+shift+方向键
跳到指定行 ctrl+g
window截图 win+shift+d
linux终端 上翻：shift+pageup
下翻：shift+pagedown
vim快捷键 输入:1,$d，即可清空文件</content></entry><entry><title>内网渗透-通信技术</title><url>/post/2023/11/13StudyNeiWang.html</url><categories><category>内网</category></categories><tags><tag>内网渗透</tag></tags><content type="html"> 背景 当拿到某网络主机的权限，发现无法将流量或者权限发送出来，对渗透造成了很大的影响，所以内网渗透必须需要了解到两种主要的通信技术–代理与隧道（端口转发）技术。
代理技术解决的问题：代理简单来讲解决网络之间的通信问题，如内网与外网之间或者两者自己之间的通信，两个不同内网的通信就必须借助到代理，否则无法通讯。
隧道技术解决的问题：简单来讲就是解决流量无法发送，隧道技术多用来绕过一些安全设备的监控，如防火墙过滤问题，网络连接通讯问题，数据回链封装问题，对我们发送的流量进行了拦截，这个时候需要接触隧道技术绕过拦截，隧道技术就是使用不同的协议把走不通的路走通。走不同的协议技术建立通讯，可以说是其中也包括了一些代理的技术
隧道（端口转发） 一般情况，在渗透测试后获取主机权限后下一步就是内网渗透，内网中的其他机器是不允许外网机器访问的。这时候，我们可以通过 隧道（端口转发） 或将这台外网服务器设置成为 代理，使得我们自己的攻击机可以直接访问与操作内网中的其他机器。实现这一过程的手段就叫做端口转发。
隧道技术使用在不同的OSI层进行，大体总结了以下三种： 网络层：IPV6隧道，ICMP隧道 传输层：TCP隧道，UDP隧道，常规的端口转发 应用层：SSH隧道，HTTP/S隧道，DNS隧道
需要注意的是，使用某种隧道之前，需要检查环境本身是否支持这种协议的使用，才能去使用响应的隧道传输。
常用工具 内网渗透中常用的代理工具有很多，例如lcx，nps，frp，venom，proxifier/proxychains+reGeorg等等。这里我就不全部讲解了。
1.LCX(Windows)/Portmap(Linux) 很有名的一款工具，杀软直接秒杀，上传到目标机器前要提前做好免杀。下载地址：https://github.com/AA8j/SecTools/tree/main/lcx
下面介绍一下使用该工具的两种场景。
（1）假如此时已经拿到了边界服务器的权限，但是由于防火墙限制，进网端口被限制，但可以出网，此时就可以将边界服务器的端口转发到攻击机上，然后访问攻击机的端口。
边界服务器为Windows：
# 攻击机上执行： ./portmap -m 2 -p1 4444（本机监听端口） -h2 127.0.0.1（转发到目的IP） -p2 3389（转发到目的端口） # 表示监听本机 …</content></entry><entry><title>GEEK极客部分WriteUp</title><url>/post/GEEK%E2%80%99sWriteUp.html</url><categories><category>CTF</category></categories><tags><tag>比赛结果</tag></tags><content type="html"><![CDATA[  一、easy_php isset($_GET[&amp;#39;syc&amp;#39;])&amp;amp;&amp;amp;preg_match(&amp;#39;/^Welcome to GEEK 2023!$/i&amp;#39;, $_GET[&amp;#39;syc&amp;#39;]) &amp;amp;&amp;amp; $_GET[&amp;#39;syc&amp;#39;] !== &amp;#39;Welcome to GEEK 2023!&amp;#39; isset($_GET[&amp;lsquo;syc&amp;rsquo;])：检查$_GET[&amp;lsquo;syc&amp;rsquo;]变量是否已设置，即检查用户是否传递了名为syc的参数。 preg_match(&amp;rsquo;/^Welcome to GEEK 2023!$/i&amp;rsquo;, $_GET[&amp;lsquo;syc&amp;rsquo;])：使用正则表达式检查$_GET[&amp;lsquo;syc&amp;rsquo;]的值是否与Welcome to GEEK 2023!完全匹配。i表示不区分大小写。 $_GET[&amp;lsquo;syc&amp;rsquo;] !== &amp;lsquo;Welcome to GEEK 2023!&amp;rsquo;：检查$_GET[&amp;lsquo;syc&amp;rsquo;]的值是否不等于Welcome to GEEK 2023！。
绕过
syc=Welcome to geek 2023! intval($_GET[&amp;#39;lover&amp;#39;]) &amp;lt; 2023 &amp;amp;&amp;amp; intval($_GET[&amp;#39;lover&amp;#39;] + 1) &amp;gt; 2024 intval($_GET[&amp;rsquo;lover&amp;rsquo;]) &amp;lt; 2023：将$_GET[&amp;rsquo;lover&amp;rsquo;]转换为整数，然后检查该整数是否小于 2023。 intval($_GET[&amp;rsquo;lover&amp;rsquo;] + 1) &amp;gt; 2024：将$_GET[&amp;rsquo;lover&amp;rsquo;]转换为整数，加 1 后，检查该整数是否大于 2024。
要求intval($num)&amp;lt;2020 &amp;amp;&amp;amp; intval($num+1)&amp;gt;2021 这里要传入一个普通的整数肯定是无法绕过的，要传过去一个科学记数法表示的数字， …  ]]></content></entry><entry><title>正向代理和反向代理</title><url>/post/1112.html</url><categories><category>代理服务</category></categories><tags><tag>代理</tag><tag>正向代理</tag><tag>反向代理</tag></tags><content type="html"> 代理通常是指用户和网页服务器之间的中介。您可能了解有各种不同用途的代理。在本文中，我们将介绍正向和反向代理服务器之间的区别。首先，我们来了解什么是正向代理和反向代理，在概念上做到认识一致。
什么是正向代理？ ​ 在大多数情况下，我们说的代理服务器指的是最普通的代理，即正向代理。这类代理位于用户之前，在用户与其访问的网页服务器之间充当中介。这就是说用户的请求要通过正向代理后才能抵达网页。从互联网检索数据后，这些数据就会被发送到代理服务器并将其重定向后返回请求者。从互联网服务器的角度来看，这个请求是有代理服务器、而不是用户发送的。正向代理还可以缓存信息并将信息用于处理今后的请求。
​ 由于正向代理可以看做访问和控制点，因此它可以提高专用网络用户的安全性，调节流量并通过隐藏原始 IP 地址而保持用户的匿名状态。
正向代理（forward proxy）：是一个位于客户端和目标服务器之间的服务器（代理服务器），为了从目标服务器取得内容，客户端向代理服务器发送一个请求并指定目标，然后代理服务器向目标服务器转交请求并将获得的内容返回给客户端。
正向代理用途 个人用户或企业出于各种原因使用正向代理：
1.访问受限地理位置。 正向代理服务器在访问受地理限制的内容时非常方便。用户浏览互联网时，他们能浏览的内容通常由自己所在的地理位置来决定。使用正向代理时，用户可以访问定位给其他国家/地区的各种内容。例如，对于提供广告验证服务的公司，这一特点尤其有用。无论这些公司处于任何地理位置，都可以自由监控广告投放。例如，您想要了解自己投放的广告在巴西是否可以显示，可以使用巴西代理；也可以用德国代理访问德国的内容。
2.确保匿名性。 正向代理服务器可以用作额外的安全保护层，可以通过使用自己的 IP 地址来隐藏网页服务器的真实IP 地址。这就是使用正向代理服务器来确保更高级别的匿名性和安全性的原因。
3.网络抓取。 代理最常见的用途是网络抓取。公司通常采集数据来帮助改进营销、定价和其他业务策略。公司可通过网络抓取有助于在市场上保持竞争力。 正向代理也可以用于控制和监控互联网的使用、创建和管理社交媒体帐户等。
什么是反向代理服务器？ 顾名思义，与代表客户端的正向代理不同，反向代理服务器位于后端服务器之前，将客户端请求转发至这些服务器。反向代理通常用于提高防护、速度和可靠度。反向代理从客户端获取请求，将 …</content></entry><entry><title>试修改莞工计科助手页面成绩</title><url>/post/1111.html</url><categories><category>网安学习</category><category>小程序</category></categories><tags><tag>burp</tag><tag>proxifier</tag><tag>小程序</tag></tags><content type="html"> 一、实践工具 代理工具：Proxifier 3.42
抓包工具：BurpSuite V2023.3.2
二、最终效果截图 三、实现原理 用Proxifier对电脑上面的小程序的流量进行代理，将流量全部导向burp的8080端口，让burp可以进行改包。
四、软件配置 1、proxifier 点击左上角的配置文件&amp;mdash;代理服务器
点击代理规则
WeChatAppex.exe是取自任务管理器中微信的应用程序名字
点击配置文件&amp;ndash;高级&amp;ndash;http代理服务器，勾上启用
2、burp 先将burp的CA证书导出安装在电脑上面，
CA(Certificate Authority，证书授权)是由认证机构服务者签发，是数字签名的技术基础保障，也是网上实体身份的证明，能够证明某一实体的身份及其公钥的合法性，证明该实体与公钥二者之间的匹配关系。
数字证书为实现双方安全通信提供了电子认证。在因特网、公司内部网或外部网中，使用数字证书实现身份识别和电子信息加密。数字证书中含有密钥对（公钥和私钥）所有者的识别信息，通过验证识别信息的真伪实现对证书持有者身份的认证。
注意选择受信任的根证书颁发机构
五、实战开始 按图实现三个应用开启
先把代理软件和抓包软件打开，打开burp的拦截
在放掉前面几个包后，会发现一个包在请求student-info接口，拦截掉他的响应包，并且放掉后面排队的请求包。
就可以看到下面这个响应包。
把上面的信息全部修改成你想要的结果即可。
如图：
​ 这次便结束了。
​ 本来这次兴起是想看看羊了个羊的通关接口还能不能用，没想到人家已经优化了，就想从前端开始搞事，倒是可以通关，但是它的服务器应该是进行了校验，没有记录我的通关数据，只能下次研究一下他的各个校验码之间之怎么校验的才能发回去正确的通关包。</content></entry><entry><title>CSRF攻击和防御</title><url>/post/CSRFstudy.html</url><categories><category>网安学习</category><category>CSRF攻击</category></categories><tags><tag>网安学习</tag><tag>CSRF</tag></tags><content type="html"><![CDATA[   CSRF攻击 CSRF 英文全称是 Cross-site request forgery，所以又称为“跨站请求伪造”，是指黑客引诱用户打开黑客的网站，在黑客的网站中，利用用户的登录状态发起的跨站请求。简单来讲，CSRF 攻击就是黑客利用了用户的登录状态，并通过第三方的站点来做一些坏事。
如下为一个简单的攻击流程。 1）假设用户打开了一个银行网站，并且登录了 2）登录成功后，会返回一个cookie给前端，浏览器将cookie保存下来 3）用户在没有登出银行网站的情况下，在当前浏览器又新打开多了一个选项卡，访问了一个危险的网站 4）这个网站有个危险的超链接，这个超链接指向了银行网站 5）用户点击这个超链接，由于这个超链接会自动携带上cookie,所以用户不知不觉在点击这个超链接的时候，还要一些请求是发到了银行网站那里去。
有漏洞的网页：
#同时支持POST和Get #接口 https://time.geekbang.org/sendcoin #参数 ##目标用户 user ##目标金额 number 发送GET请求 // 在黑客的页面诱导用户点击图片，发出一个get请求。 // 如果目标服务器足够傻，就能实施一次csrf攻击 &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;黑客的站点：CSRF攻击演示&amp;lt;/h1&amp;gt; &amp;lt;img src=&amp;#34;https://time.geekbang.org/sendcoin?user=hacker&amp;amp;number=100&amp;#34;&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 发送 POST 请求 // 在黑客的页面发出一个post请求。 // 如果目标服务器足够傻，就能实施一次csrf攻击 &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;body&amp;gt; &amp;lt;h1&amp;gt;黑客的站点：CSRF攻击演示&amp;lt;/h1&amp;gt; &amp;lt;form id=&amp;#39;hacker-form&amp;#39; action=&amp;#34;https://time.geekbang.org/sendcoin&amp;#34; method=POST&amp;gt; &amp;lt;input type=&amp;#34;hidden&amp;#34; …  ]]></content></entry><entry><title>学习DLL注入</title><url>/post/DLLstudy.html</url><categories><category>windows</category><category>DLL</category></categories><tags><tag>Windows</tag><tag>DLL</tag></tags><content type="html"> dll文件简介 ​ .dll文件是Dynamic Link Library（动态链接库）文件的缩写，它是一种共享库文件，包含了程序所需的代码和数据。与静态链接库不同，动态链接库可以在程序运行时动态加载，使得程序的内存占用更小，同时也方便了程序的更新和维护。然而，这并不意味着我们不能以任何其他形式（可执行文件、手写文件等）注入程序集。需要注意的是，您需要在系统上拥有适当级别的权限才能开始使用其他程序的内存。
.dll文件的背景和相关作用 .dll文件最早出现在Windows 3.1操作系统中，用于解决内存资源不足的问题。随着Windows操作系统的发展，.dll文件也逐渐成为了Windows操作系统的重要组成部分。
.dll文件有许多重要的作用，其中包括：
提高程序的可重用性。通过将公共代码封装到.dll文件中，可以使得不同的程序都可以共享这些代码，从而提高程序的可重用性。 减少程序的内存占用。由于.dll文件可以在程序运行时动态加载，所以可以减少程序的内存占用，提高系统的运行效率。 方便程序的更新和维护。由于.dll文件可以独立于程序而存在，所以可以方便地对程序进行更新和维护，而不需要重新编译整个程序。 提高程序的安全性。由于.dll文件可以被多个程序共享，所以可以减少程序中的重复代码，从而降低程序的漏洞风险。 关于dll注入技术 ​ DLL注入技术可以被正常软件用来添加/扩展其他程序，调试或逆向工程的功能性；比如，反病毒软件和端点安全解决方案使用这些技术来将其软件的代码嵌入/拦截系统中“所有”正在运行的进程，这使得它们可以在其运行过程中监控每一个进程，从而更好地保护我们。该技术也常被恶意软件以多种方式利用。一种经常被用到的通用技术是注入“lsass”进程来获取口令哈希值。我们之前都这么干过。很明显，恶意代码同样广泛应用了代码注入技术：不管是运行shellcode代码，运行PE文件，还是在另一个进程的内存空间中加载DLL文件以隐藏自身，等等。 ​ 这意味着从安全角度来说，了解DLL注入的工作原理是十分必要的。
​ Windows API 实际上提供了许多函数，允许我们附加和操作其他程序以进行调试。我们将利用这些方法来执行 DLL 注入。我将 DLL 注入分为四个步骤：
附加到进程
在进程内分配内存
将DLL 或 DLL 路径复制到进程内存中并确定适当的内存地址
指示 …</content></entry><entry><title>编码是什么</title><url>/post/%E7%BC%96%E7%A0%81%E6%98%AF%E4%BB%80%E4%B9%88.html</url><categories><category>字符编码</category></categories><tags><tag>字符编码</tag></tags><content type="html"> 字符集与字符编码 ​ 字符是各种文字和符号的总称，包括各个国家文字、标点符号、图形符号、数字等。字符集是多个字符的集合，字符集种类较多，每个字符集包含的字符个数不同，常见字符集有：ASCII字符集、ISO 8859字符集、GB2312字符集、BIG5字符集、GB18030字符集、unicode字符集等。计算机要准确的处理各种字符集文字，需要进行字符编码，以便计算机能够识别和存储各种文字。 ​ 编码(encoding)和字符集不同。字符集只是字符的集合，不一定适合作网络传送、处理，有时须经编码(encode)后才能应用。如unicode可依不同需要以UTF-8、UTF-16、UTF-32等方式编码。
​ 字符编码就是以二进制的数字来对应字符集的字符。因此，对字符进行编码，是信息交流的技术基础。
​ 使用哪些字符。也就是说哪些汉字，字母和符号会被收入标准中。所包含“字符”的集合就叫做“字符集”。规定每个“字符”分别用一个字节还是多个字节存储，用哪些字节来存储，这个规定就叫做“编码”。
编码问题的由来、相关概念的理解 从计算机对多国语言的支持角度看，大致可以分为三个阶段：
系统内码 说明 系统 阶段一 ASCII 计算机刚开始只支持英语，其它语言不能够在计算机上存储和显示。 英文 DOS 阶段二 ANSI编码 （本地化） 为使计算机支持更多语言，通常使用 0x80~0xFF 范围的 2 个字节来表示 1 个字符。比如：汉字 &amp;amp;lsquo;中&amp;amp;rsquo; 在中文操作系统中，使用 [0xD6,0xD0] 这两个字节存储。 不同的国家和地区制定了不同的标准，由此产生了 GB2312, BIG5, JIS 等各自的编码标准。这些使用 2 个字节来代表一个字符的各种汉字延伸编码方式，称为 ANSI 编码。在简体中文系统下，ANSI 编码代表 GB2312 编码，在日文操作系统下，ANSI 编码代表 JIS 编码。 不同 ANSI 编码之间互不兼容，当信息在国际间交流时，无法将属于两种语言的文字，存储在同一段 ANSI 编码的文本中。 中文 DOS，中文 Windows 95/98，日文 Windows 95/98 阶段三 UNICODE （国际化） 为了使国际间信息交流更加方便，国际组织制定了 UNICODE 字符集，为各种语言中的每一个字符设定了统一并且唯一的数字编号，以满足跨 …</content></entry><entry><title>关于数据库的学习和拓展</title><url>/post/RDBMS%E5%92%8Cnosql%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%89%A9%E5%B1%95.html</url><categories><category>数据库</category></categories><tags><tag>数据库</tag><tag>SQL</tag><tag>分布式</tag><tag>区块链</tag></tags><content type="html"> 数据库简介 数据库是数据管理的重要技术，也是计算机的重要分支。
数据库管理系统是一种操纵和管理数据库的大型软件，用于建立、使用和维护数据库，简称 DBMS。
根据存储模型可将数据库划分为关系型数据库和非关系型数据.。
简单来说，关系模型指的就是二维表格模型，而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织。标准数据查询语言 SQL 就是一种基于关系数据库的语言，这种语言执行对关系数据库中数据的检索和操作。
关系型数据库 Oracle：甲骨文开发的商业数据库，不开源，支持所有主流平台，性能好，功能强，稳定性好，安全性好，支持大数据量，比较复杂，收费昂贵。
SQL Server：微软开发的商业数据库，只能在 Windows 运行。
MySQL：甲骨文拥有的开源数据库，支持多种操作系统，体积小，功能弱些，简单的操作性能好，复杂的操作性能差些。
PostgreSQL：使用 BSD 协议的完全开源免费的项目，支持多种操作系统，功能更强大，可以和多种开源工具配合。
SQLite：开源、轻型、无服务器、零配置，一个数据库就只是一个文件，在应用程序内执行操作，占用资源小，可用于嵌入式或小型应用。
Microsoft Access、Sybase
应用场景 Oracle 多用于银行等高要求的领域，要求不高的比如互联网行业多用 MySQL 和 PostgreSQL，而 SQLite 用于嵌入式或作为应用程序内的数据库使用，SQL Server 用于 Window 服务器。相比于 SQL Server这样的企业级数据库管理系统，Microsoft Access更适合用于个人或小团队的本地数据库需求。适用于多种企业级应用和数据存储需求。Sybase具有高性能、可靠性和扩展性的特点，适合处理大规模和复杂的数据，被广泛用于各种行业和领域。
非关系型数据库 ​ 非关系型数据库是分布式的、非关系型的、不保证遵循ACID原则的数据存储系统。NoSQL最常见的解释是“non-relational”，“Not Only SQL”也被很多人接受。流行的NoSQL数据库有Couchbase，MongoDB，Redis，BigTable和RavenDB。
它们通常不使用固定的表格结构和SQL语言。非关系型数据库适用于需要处理大规模和动态的数据集合，以及需要更高的可伸缩性和性能的场景。
以下是一些 …</content></entry><entry><title>使用hugo框架创建个人博客</title><url>/post/hugostudy.html</url><categories><category>个人博客</category><category>hugo</category></categories><tags><tag>个人博客</tag><tag>hugo</tag></tags><content type="html"><![CDATA[  一、配置环境 https://github.com/gohugoio/hugo/releases 下载window版本的hugo(如果该版本不属于你的window操作系统则下载最下面一行的hugo_extended_0.116.0_windows-amd64.zip这一个资源文件)
配置系统环境，可以在电脑所有文件夹使用hugo.exe
通过输入命令让hugo框架快速建立博客
hugo new site mysite mysite文件夹内部结构（当前文件夹仍然是空白博客，只是有了一个框架）：
&ndash;themes 博客风格
&ndash;content 博客全部文章
&ndash;static 博客静态文件（比如博客ico文件）
&ndash;layouts 博客风格文件
&ndash;hugo.toml 博客配置文件（刚创建时候没什么用）
文件并不是全部都有用，主要看博客主题的撰写者是否在用，但是content，themes，static肯定有用，小白后面可以仔细研究一下。
二、主题选择 接下来找到自己喜欢的主题文件下载
https://themes.gohugo.io/ 对小白有一个选主题文件的建议。观察主题文件是否有例子网站。如下图
有这个文件在里面，配置这个的博客会简单不少
将所有的examplesite的文件往你的博客文件夹复制，并用config.yaml文件代替hugo.toml文件，因为这两个配置文件会冲突。
接下来将整个主题文件夹搬运到我们博客目录的themes文件夹中
然后用一个编辑器打开config.yaml文件查看各个配置是否正确，主要是看主题名字是否符合。
有些主题名字从GitHub下面下载下来的名字和配置里面的不一样。
我们需要将主题名字和我们themes文件夹里面的想用的主题名字配置一样。
然后在博客文件夹打开cmd终端输入hugo server，
如果出现下列localhost:1313,即为在本地正确配置博客
这只是小白在本地配置hugo博客的一部分，还没有上传到代码托管平台。
不知道还会不会出续集，已知道的代码托管平台有github、gitee等
gitee需要实名认证，github需要翻墙部署。
推荐其他部署文章 https://zhuanlan.zhihu.com/p/105021100   ]]></content></entry><entry><title>Nmap学习使用</title><url>/post/Nmapstudy.html</url><categories><category>网安学习</category><category>Nmap</category></categories><tags><tag>网安学习</tag><tag>Nmap</tag></tags><content type="html"> 介绍 Nmap (Network Mapper) 是一个开源的网络扫描工具，用于发现主机和服务，并识别网络上的开放端口。它广泛用于网络管理员、安全专家和黑客等领域。Nmap提供了丰富的功能和参数，使其成为一种功能强大的网络探测工具。
底层原理 Nmap是用C和Lua两种编程语言编写的。
C语言：Nmap的核心功能是用C语言编写的。C语言为Nmap提供了高效的性能和跨平台的特性，使其能在各种操作系统上运行。 Lua脚本语言：Nmap引入了Lua作为脚本语言，用于编写自定义脚本和扩展功能。通过Lua脚本，用户可以实现更多自定义的扫描和探测行为，充分利用Nmap强大的网络探测能力。 使用方法 nmap [扫描目标] [参数] 示例 扫描单个主机： nmap 192.168.0.1 扫描多个主机： nmap 192.168.0.1 192.168.0.2 192.168.0.3 扫描整个子网： nmap 192.168.0.0/24 扫描特定端口： nmap -p 80 192.168.0.1 扫描常见端口： nmap -F 192.168.0.1 参数 基本扫描选项： -sS：TCP SYN 扫描（默认）。 -sT：TCP connect 扫描。 -sU：UDP 扫描。 -sF：FIN 扫描。 -sX：Xmas 树扫描。 -sP：Ping 扫描，用于检测目标主机是否在线。 端口扫描选项： -p ：指定要扫描的端口范围，可以是单个端口或连续端口范围。例如：-p 80 或 -p 1-100. -F：快速扫描，仅扫描常见端口。 输出选项： -oN ：以正常格式将结果输出到文件。 -oX ：以XML格式将结果输出到文件。 -oG ：以Grepable格式将结果输出到文件。 服务/版本探测选项： -sV：探测服务和版本信息。 操作系统探测选项： -O：尝试猜测目标操作系统类型。 路径追踪（Traceroute）选项： --traceroute：路径追踪功能。 脚本扫描选项： -sC：使用默认脚本进行扫描。 --script=：指定要使用的脚本。 防火墙/IDS逃避选项： -f：分片扫描。 -D ：伪装成多个IP以逃避防火墙/IDS。 并行扫描选项： -T&amp;amp;lt;0-5&amp;amp;gt;：设置扫描速度/时间延迟。例如：-T4 表示普通扫描。 其他选项： -v：详细模式，显示更多输出信息。 …</content></entry><entry><title>SQLMAP学习使用</title><url>/post/sqlmapstudy.html</url><categories><category>网安学习</category><category>sqlmap</category></categories><tags><tag>网安学习</tag><tag>sqlmap</tag></tags><content type="html"> SQL描述 SQLMap是一款开源的渗透测试工具，主要用于检测和利用SQL注入漏洞。它是由Burp Suite工具的开发者Bernardo Damele和Miroslav Stampar创建的，并在Python语言下开发。SQL注入是一种常见的网络应用程序漏洞，通过此漏洞，攻击者可以在应用程序的数据库中执行恶意的SQL查询，从而获取敏感数据、修改数据或者对数据库进行非授权的访问。
sqlmap 是一款由 Python 语言编写的自动化检测与利用 SQL 注入漏洞的免费开源工具，支持对多种 SQL 注入的检测和利用，同时也完美支持 MySQL、Oracle、PostgreSQL、MSSQL、Access 等主流数据库
语言：python
参数列表 -u URL: 指定目标URL，用于测试是否存在SQL注入漏洞。 --data DATA: 指定POST请求的数据，用于测试POST请求中的SQL注入漏洞。 --cookie COOKIES: 设置HTTP请求中的Cookie信息。 --random-agent: 使用随机User-Agent头来隐藏请求的来源。 --level LEVEL: 设置测试的注入深度，范围从1到5，默认为1。 --risk RISK: 设置测试的注入风险级别，范围从1到3，默认为1。 --threads THREADS: 设置并发线程的数量。 --dbs: 列出数据库管理系统的所有数据库。 --tables: 列出指定数据库中的所有表。 --columns: 列出指定表中的所有列。 --dump: 获取指定表的数据。 --os-shell: 获取操作系统级别的shell。 --os-pwn: 获取操作系统级别的交互式shell。 --sql-shell: 获取数据库的SQL shell。 --tamper TAMPER: 使用指定的脚本来修改请求中的参数，用于绕过WAF等安全机制。 --crawl: 自动进行爬行，从一个页面发现和测试其他链接。 --batch: 使用批量模式，不需要用户交互。 使用sqlmap进行扫描漏洞过程 确定目标：首先，确定要测试的目标网站和页面。可以是一个URL或者页面表单。
检测是否存在SQL注入漏洞：使用SQLMap对目标进行扫描，检测是否存在SQL注入漏洞。可以通过以下命令来进行测试：
sqlmap -u …</content></entry><entry><title>关于进程控制</title><url>/post/custom-files.html</url><categories><category>Linux</category></categories><tags><tag>window</tag><tag>进程</tag><tag>Linux</tag></tags><content type="html"><![CDATA[  Windows的TASKLIST TASKLIST [/S system [/U username [/P [password]]]] [/M [module] | /SVC | /V] [/FI filter] [/FO format] [/NH]
描述 该工具显示在本地或远程机器上当前运行的进程列表。
参数列表: /S system 指定连接到的远程系统。 /U &amp;lt;username&amp;gt; 指定应该在哪个用户上下文执行这个命令。 /P 为提供的用户上下文指定密码。如果省略，则 提示输入。 /M 列出当前使用所给 exe/dll 名称的所有任务。如果没有指定模块名称，显示所有加载的模块。 /SVC 显示每个进程中主持的服务。 /V 显示详述任务信息。 /FI 显示一系列符合筛选器指定的标准的任务。 /FO format 指定输出格式。 有效值: &amp;ldquo;TABLE&amp;rdquo;、&amp;ldquo;LIST&amp;rdquo;、&amp;ldquo;CSV&amp;rdquo;。 /NH 指定列标题不应该在输出中显示。 只对 &amp;ldquo;TABLE&amp;rdquo; 和 &amp;ldquo;CSV&amp;rdquo; 格式有效。 /? 显示帮助消息。 示例 若要列出进程 ID 大于 1000 的所有任务，并将它们以 csv 格式显示，请键入：
tasklist /v /fi &amp;#34;PID gt 1000&amp;#34; /fo csv 若要列出当前正在运行的系统进程，请键入：
tasklist /fi &amp;#34;USERNAME ne NT AUTHORITY\SYSTEM&amp;#34; /fi &amp;#34;STATUS eq running&amp;#34; 若要列出当前正在运行的所有进程的详细信息，请键入：
tasklist /v /fi &amp;#34;STATUS eq running&amp;#34; 若要使用用户帐户 Hiropln 的凭据列出远程计算机 srvmain 上的进程，请键入：
tasklist /s srvmain /u maindom\hiropln /p p@ssW23 Windows的TASKKILL 描述 结束一个或多个任务或进程。 可以通过进程 ID 或图像名称结束进程。 可以使用 tasklist 命令来确定要结束的进程的进程 ID (PID)。
参数列表 /s …  ]]></content></entry><entry><title>爬取学校官网通知</title><url>/post/%E7%88%AC%E5%8F%96%E5%AD%A6%E6%A0%A1%E5%AE%98%E7%BD%91%E9%80%9A%E7%9F%A5/</url><categories><category>python</category><category>爬虫</category></categories><tags/><content type="html"><![CDATA[  爬虫开始 首先看到页面呈现规则的各个方框，这意味着它们之间的一定是一样的
此处该有图
我们点开后台可以看见属于通知活动的代码中很多这类”li“标签
&amp;lt;li&amp;gt; &amp;lt;a href=&amp;#34;../info/1042/48792.htm&amp;#34; target=&amp;#34;_blank&amp;#34; title=&amp;#34;关于开展2018届毕业生中期发展评价的通知&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;box&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;time&amp;#34;&amp;gt; &amp;lt;div class=&amp;#34;ll&amp;#34;&amp;gt; &amp;lt;img src=&amp;#34;../images/list_box_07_ico.png&amp;#34; alt=&amp;#34;&amp;#34;&amp;gt;2023.06.09 &amp;lt;/div&amp;gt; &amp;lt;div class=&amp;#34;rr&amp;#34;&amp;gt; &amp;lt;img src=&amp;#34;../images/list_box_24_ico.png&amp;#34; alt=&amp;#34;&amp;#34;&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;h5 class=&amp;#34;overfloat-dot-2&amp;#34;&amp;gt;关于开展2018届毕业生中期发展评价的通知&amp;lt;/h5&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/ 那么我们可以分别截取一下几个标签，分别是
时间标签：&amp;lt;div class=&amp;#34;ll&amp;#34;&amp;gt; 标题标签：&amp;lt;h5 class=&amp;#34;overfloat-dot-2&amp;#34;&amp;gt; 前期工作准备结束了，让我们打开pycharm，引入本次的包
import requests #经典请求包 from bs4 import BeautifulSoup import pandas as pd #生成xlsx文档包 为了我们的页面的中文正常输出，我们必须对获取的内容进行一个转码
url = &amp;#39;example.com&amp;#39; + str(page) + &amp;#39;.htm&amp;#39; r = requests.get(url) r.encoding = &amp;#39;utf-8&amp;#39; 我观察到页面的顺序并不是从1往后的，而是从第12页为1.html， …  ]]></content></entry><entry><title>关于我</title><url>/about.html</url><categories/><tags/><content type="html"> 月白星辰挂长空；萦绕悠扬寂寥风。
舞琴弄墨各不同；骑马过海踏天虹。
这个博客会写一些学习心得，和生活随笔。 有时候会很懒，心情也会不固定，时晴时雨，就想写博客记录自己的生活。
曾经有个笔名叫幻天林少，还写过小说，当时还是太天真了，不过还是算一个能在互联网搜索到的男人了，做一个自己的小小天地，在互联网这个世界中留下自己的印记。
这个博客开始于2023年5月~~~</content></entry><entry><title>Codebreakers战队 WriteUp</title><url>/post/Codebreakers%E2%80%99sWriteUp.html</url><categories><category>CTF</category></categories><tags><tag>比赛结果</tag></tags><content type="html"> 排名 战队名称：第225名
]
解题思路 1、解压管道压缩包得到一张图片
2、将图片用StegSolve打开，不断查看图片各个通道，会发现在单色0通道上左上角出现白色条纹，却中间图案非常混杂，即可得知在图片的混杂数据。
打开analyse的data extract 选择red 0 Column参数，点击Preview
第一行即出现flag
flag{098 8f2a657d8936a76876d4f39f7d7a0} 图片文件：
https://wwcb.lanzouw.com/i9qgI0y5a17i</content></entry><entry><title>ICMP数据报ping命令</title><url>/post/ping%E5%91%BD%E4%BB%A4/</url><categories><category>计算机网络</category><category>ICMP</category></categories><tags/><content type="html"> Q: 结合实例“ping www.sina.com ”给出 ping 命令的原理。
Ping命令是一种常用的网络诊断工具，可以检测主机之间的联通性，测试网络连接速度和带宽使用情况。该命令发送一个数据包到目标主机，然后等待该主机响应，并记录来自目标主机的回复时间和信息，以供分析使用。
例如，在命令行中运行“ping www.sina.com ”，我们可以看到我们的计算机向新浪网站发送了一个数据包，网站以回复给我们，这里如果想更准确的说明原理，我们需要在网络模型中进行解释，简化地将其分为以下几个步骤：
应用层：用户在终端设备输入ping命令并按下回车，操作系统通过应用层协议将输入的命令传递给传输层。
传输层：操作系统通过传输层协议将ping命令和其他必要信息打包成域数据报并发往底层网络。此处一般使用ICMP协议。
网络层：DNS服务负责将www.sina.com解析为其对应的IP地址，并告诉我们的计算机。
数据链路和物理层：数据包被转化为数据流，并在网络上通过一系列数据链路和物理层传输，最终抵达目标主机。
目标主机收到数据包，操作系统将回复包打包成数据帧并通过网络发往我们的计算机。
返回数据经过数据链路和物理层传输，最终抵达我们的计算机，操作系统将其解析为人们可读的格式并在命令行中输出。
Ping命令利用了ICMP数据报协议，通过给目标主机发送数据包和等待其回复，来检测网络连接和其他问题的存在，并记录网络性能以供诊断使用。</content></entry><entry><title>ICMP数据报tracert命令</title><url>/post/tracert%E5%91%BD%E4%BB%A4/</url><categories><category>计算机网络</category><category>ICMP</category></categories><tags/><content type="html"> Q: 结合实例“tracert www.163.com ”给出 tracert 命令的原理。
tracert命令是一款常用的网络诊断工具，它可以追踪Internet上从一个起始点到达另一个目的地的路由路径，并显示每个跃点的延迟时间。当我们执行“tracert www.163.com ”的时候，操作系统就会发送一系列的数据包探测从本机到目标地址的路由，其中包括访问的每个信号跳跃点的详细信息。接下来，我将简要介绍一下“tracert”命令的原理。
应用层：用户在终端设备输入tracert命令并按下回车，操作系统通过应用层协议将输入的命令传递给传输层。
传输层：操作系统通过传输层协议将tracert命令和其他必要信息打包成域数据报并发往底层网络。此处一般使用ICMP协议。
网络层：DNS服务负责将www.163.com解析为其对应的IP地址，并告诉我们的计算机。
数据链路和物理层：数据包被转化为数据流，并在网络上通过一系列数据链路和物理层传输，最终抵达目标主机。
目标主机收到数据包并返回结果，但是这个时候 tracert 命令不会停止工作；删除不在路由路径中的信息，并继续向远程主机发送数据包。当跃点信息关于目标系统返回时，则显示到终端上。
返回数据经过数据链路和物理层传输，最终抵达我们的计算机，操作系统将其解析为人们可读的格式并在命令行中输出。
总之，“tracert”命令利用ICMP协议特别设计的“时间超时”机制，通过发送数据包，跟踪这些数据包经过的每个路由器，最终确定到达目标地址所需的最佳路线。逐级探测路由器的原理是基于TTL值（Time to Live），它告诉路由跳出期限已过期的报文需要被丢弃。该信息源于每个传输包中的IP头部，一开始被设定成一定的值，中转节点的路由器在收到此类数据包后，会减1并再次转发给下一跃点，这样每一个中转节点就会更新TTL值，直到最后一个到达目的地址。这些来回传输的数据包的交互过程显示了网络连接的性能和路由可能出现的问题，帮助管理员更好地诊断和修复网络问题。</content></entry><entry><title>ICMP数据报Identifier中BE和LE的区别</title><url>/post/BEorLE.html</url><categories><category>计算机网络</category><category>ICMP</category></categories><tags/><content type="html"> Q: 在icmp数据报中的标识符 Identifier (BE): 512 (0x0200) Identifier (LE): 2 (0x0002)这两个标识符有什么区别，有什么用，说个例子解释一下
这两个标识符都是 ICMP 报文中的标识符字段，用于标识发送方发送的 ICMP 报文。区别在于 BE 和 LE 分别代表大端序和小端序，即字节序的不同。
在网络通信中，不同的计算机可能使用不同的字节序，因此需要在传输数据时进行字节序的转换，以保证数据的正确性。在 ICMP 报文中，标识符字段是一个 16 位的无符号整数，因此需要在传输时进行字节序的转换。
例如，当一个大端序的计算机向一个小端序的计算机发送 ICMP 报文时，标识符字段需要进行字节序的转换，将 BE 的值 512 转换为 LE 的值 2。这样接收方才能正确地识别发送方发送的 ICMP 报文。
总之，标识符字段的作用是用于标识发送方发送的 ICMP 报文，而 BE 和 LE 则是用于表示不同字节序的标识符值，以保证数据在网络传输中的正确性。</content></entry><entry><title>Linux自启动方式</title><url>/post/Linux%E8%87%AA%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F.html</url><categories><category>Linux</category></categories><tags/><content type="html"> 在Linux中，有多种方式可以设置开机自启动。以下是几种常见的方式：
使用init.d或rc.d脚本：在/etc/init.d/或/etc/rc.d/目录中，你可以创建一个启动脚本，并使用特定的命名约定（如以&amp;quot;S&amp;quot;开头并在其后跟一个数字来定义启动顺序）。这些脚本将在系统引导过程中自动执行。例如，你可以将启动脚本放在/etc/init.d/myscript，然后使用以下命令将其添加到启动过程中：
sudo chmod +x /etc/init.d/myscript sudo update-rc.d myscript defaults 使用systemd服务：systemd是用于管理系统进程和服务的初始化系统。你可以创建一个自定义的systemd服务单元文件，将其放置在/etc/systemd/system/目录中，并使用systemctl命令启用它。例如，你可以创建一个名为myservice.service的服务单元文件，然后使用以下命令启用它：
sudo systemctl enable myservice.service 使用cron作业：cron是Linux系统中的定时任务管理器。你可以编辑cron表以指定在系统引导时运行的命令或脚本。使用crontab -e命令编辑当前用户的cron表，并添加一个@reboot行来指定在系统引导时执行的命令。例如：
@reboot /path/to/myscript.sh 请注意，以上这些方法可能在不同的Linux发行版中略有差异。因此，你可能需要根据你所使用的特定发行版进行适当的调整。</content></entry><entry><title>图解HTTP</title><url>/post/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%AC%94%E8%AE%B0/</url><categories><category>计算机网络</category><category>HTTP</category></categories><tags/><content type="html"> 图解HTTP HTTP协议的职责（客户端） 生成针对目标web服务器的HTTP请求报文
TCP协议的职责（客户端） 为了方便通信，将HTTP请求报文分割成报文段按序号分成多个报文段，把每个报文段可靠地传给对方
IP协议的职责（路由器） 搜索对方的地址，一边中转一边传送
TCP协议的职责（服务器） 从对方接受到的报文段按序号以原来的顺序重组请求报文
HTTP协议的职责（服务器） 对web服务器请求的内容处理 ，请求的处理结果按照TCP/IP通信协议向用户进行回传
URL（Uniform Resource Identifier） 某个协议方案表示的资源的定位标识符
Uniform 规定统一的格式可方便处理多种不同类型的资源，而不用根据上下文环境来识别资源指定的访问方式。另外加入新的协议方案如:http、ftp也容易
Resource 资源定义是可标识的如何东西。资源不仅仅是单一的，也可以是多数的集合体。
Identifier 表示可标识的对象，也称为标识符
告知服务器意图的HTTP方法 GET 获得资源，get方法用来请求访问已被URI识别的资源
POST 用来传输实体的主体，虽然GET方法也可以传输实体的主体，但一般不用GET方法进行传输，而是用post
PUT 传输文件，就像ftp协议的文件上传，要求请求报文的主体中包含文件内容，然后保存在请求URI指定的位置。但是鉴于HTTP/1.1的PUT自身不带有验证机制，任何人都能上传，存在安全问题，因此一般web网站不采用这种方法
HEAD HEAD方法和GET方法一样，只是不返回报文主体，用于确认URI的有效性及资源更新的日期时间等
DELETE 和PUT相反的方法，但一般网站不带有验证机制，所以也不使用该方法，当配合web应用程序的验证机制，或遵守REST标准时还是有可能开放使用（PUT同）
OPTIONS 用来查询针对请求URI指定的资源支持的方法
“你支持什么方法”“支持GET和HEAD方法”
TRACE 追踪路径，让web服务器端将之前的请求通信环回给客户端的方法。但是TRACE方法本来不怎么常用，再加上它容易引发XST（Cross Site Tracing,跨站追踪）攻击，通常更不会使用了。
CONNECT 要求使用隧道协议连接代理。要求在与代理服务器通信时建立隧道，实现隧道协议进行TCP通信。主要使用SSL（ …</content></entry><entry><title>Vue项目学习</title><url>/post/Studyweb.html</url><categories><category>Vue</category></categories><tags/><content type="html"><![CDATA[  Vue学习笔记 一、二维数组尝试 var vm = new Vue({ el: &#34;#app&#34;, data: { huilv:[ [6.8540, 132.9787, 1298.7013, 1.3278], [6.8540, 132.9787, 1298.7013, 1.3278] ],} 二、watch监听实现 watch: { first: function(newValue) { this.second = newValue * this.huilv[Number(this.firstbutton - 1)][Number(this.secondbutton -1)]; }, second: function(newValue) { this.first = newValue / this.huilv[Number(this.firstbutton - 1)][Number(this.secondbutton -1)]; } } 三、数组的更新检测 #变更方法 Vue 将被侦听的数组的变更方法进行了包裹，所以它们也将会触发视图更新。这些被包裹过的方法包括：
push() pop() shift() unshift() splice() sort() reverse() 你可以打开控制台，然后对前面例子的 items 数组尝试调用变更方法。比如 example1.items.push({ message: 'Baz' })。
四、链接数据库 得到数据库的消息 getmessage() { const self = this; self.$http.post(&#39;/api/user/getchat&#39;).then(function(response) { console.log(response.data); self.messages = response.data; }).catch(function(error) { console.log(error); }); }, 提供获得数据的路由表内的接口 router.post(&#39;/getchat&#39;, (req, res) =&gt; { const sql = $sql.userchat.getmessage; conn.query(sql, (err, result) =&gt; { if (err) { console.log(err); res.json({ success: false, message: &#39;Database error occurred.&#39; }); return; } console.log(result); // 在控制台上打印查找到的结果 res.json(result); // 将查询结果返回给客户端 }); }); 将数据通过post方法提交的数据库 self.$http.post(&#39;/api/user/addchat&#39;, data).then(function(response) { console.log(response.data); self.messages.push({ name: username, message: self.newMessage, time: dateTime, }); self.newMessage = &#34;&#34;; }).catch(function(error) { console.log(error); } 在路由表提供提交的数据的接口 router.post(&#39;/addchat&#39;, (req, res) =&gt; { var sql_send = $sql.userchat.addmessage; var params = req.body; // 提取请求体中的数据 // 建立连接，向表中插入值，INSERT INTO userchat() VALUES(?, ?) conn.query(sql_send, [params.name, params.message,params.time], function(err, result) { if (err) { console.log(err); res.status(500).json({ error: &#39;Database error occurred.&#39; }); return; } console.log(result); if (result.affectedRows &gt; 0) { res.json({ success: true, message: &#39;Message sent successfully&#39;}); } else { res.json({ success: false, message: &#39;Failed to send message.&#39;}); } }); }); sqlmap内容 sqlmap提供给接口语句
如：
var sql_send = $sql.userchat.addmessage; 这个就是调用接口上的addmessage语句拼接mysql语句实现对数据库操作
var sqlMap = { user: { add: &#39;insert into user (username, account, password, repeatPass, email, phone, card, birth, sex) values (?,?,?,?,?,?,?,?,?)&#39;, select_name: &#39;select * from user &#39;, //部分查询语句 update_user: &#39;update user set &#39; ,//部分查询语句 }, userchat: { // 聊天消息操作 SQL 语句 Object，注意要加上 {} addmessage: &#39;INSERT INTO userchat(name,message,time) VALUES(?,?,?)&#39;, getmessage: &#39;select * from userchat &#39;, } }   ]]></content></entry><entry><title>友情链接</title><url>/flinks.html</url><categories/><tags/><content type="html"></content></entry></search>